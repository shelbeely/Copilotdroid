package com.agenthq.app.data.session

import com.agenthq.app.data.api.models.PullRequest
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class SessionInferenceEngine @Inject constructor() {

    companion object {
        private const val COPILOT_BOT_LOGIN = "copilot[bot]"
        private val COPILOT_BRANCH_PREFIXES = listOf("copilot/", "agent/")
        private val COPILOT_LABEL_KEYWORDS = listOf("copilot", "agent")
        private val COPILOT_BODY_MARKERS = listOf(
            "Generated by Copilot",
            "Co-authored-by: Copilot",
            "copilot-generated",
            "Copilot Workspace"
        )
        private val ISSUE_REF_PATTERN = Regex(
            """(?:Fixes|Closes|Resolves)\s+#(\d+)""",
            RegexOption.IGNORE_CASE
        )
    }

    /**
     * Returns true if the PR was likely created by a Copilot coding agent session.
     * Conservative: requires at least one strong signal.
     */
    fun isCopilotSession(pr: PullRequest): Boolean {
        return isAuthorCopilotBot(pr) ||
            isCopilotBranch(pr) ||
            hasCopilotLabel(pr) ||
            hasCopilotBodyMarker(pr)
    }

    /**
     * Extracts session metadata from a PR identified as a Copilot session.
     * If the PR is not a Copilot session, returns UNKNOWN metadata.
     */
    fun inferSessionMetadata(pr: PullRequest): SessionMetadata {
        if (!isCopilotSession(pr)) {
            return SessionMetadata(
                sessionType = SessionType.UNKNOWN,
                isAutomated = false
            )
        }

        val sessionType = inferSessionType(pr)
        val issueReference = extractIssueReference(pr)
        val agentModel = extractAgentModel(pr)

        return SessionMetadata(
            sessionType = sessionType,
            isAutomated = isAuthorCopilotBot(pr),
            issueReference = issueReference,
            agentModel = agentModel
        )
    }

    private fun isAuthorCopilotBot(pr: PullRequest): Boolean {
        val login = pr.user.login.lowercase()
        return login == COPILOT_BOT_LOGIN || login == "copilot"
    }

    private fun isCopilotBranch(pr: PullRequest): Boolean {
        val ref = pr.head.ref.lowercase()
        return COPILOT_BRANCH_PREFIXES.any { ref.startsWith(it) }
    }

    private fun hasCopilotLabel(pr: PullRequest): Boolean {
        return pr.labels.any { label ->
            val name = label.name.lowercase()
            COPILOT_LABEL_KEYWORDS.any { keyword -> name.contains(keyword) }
        }
    }

    private fun hasCopilotBodyMarker(pr: PullRequest): Boolean {
        val body = pr.body ?: return false
        return COPILOT_BODY_MARKERS.any { marker ->
            body.contains(marker, ignoreCase = true)
        }
    }

    private fun inferSessionType(pr: PullRequest): SessionType {
        val body = pr.body?.lowercase() ?: ""
        val branchRef = pr.head.ref.lowercase()

        if (body.contains("copilot workspace")) {
            return SessionType.COPILOT_WORKSPACE
        }
        if (isAuthorCopilotBot(pr) || branchRef.startsWith("copilot/") || branchRef.startsWith("agent/")) {
            return SessionType.COPILOT_AGENT
        }
        // Fallback: if isCopilotSession() matched (e.g. via label), default to COPILOT_AGENT
        return SessionType.COPILOT_AGENT
    }

    private fun extractIssueReference(pr: PullRequest): String? {
        val body = pr.body ?: return null
        val match = ISSUE_REF_PATTERN.find(body)
        return match?.groupValues?.get(1)?.let { "#$it" }
    }

    private fun extractAgentModel(pr: PullRequest): String? {
        val body = pr.body ?: return null
        val modelPattern = Regex("""model[:\s]+([a-zA-Z0-9._-]+)""", RegexOption.IGNORE_CASE)
        return modelPattern.find(body)?.groupValues?.get(1)
    }
}
